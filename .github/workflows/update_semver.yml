name: Update Semver

on:
  pull_request:
    types: [closed]
    branches:
      - master

jobs:
  update-semver_if_merged:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest

    steps:
      - name: Check out code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          persist-credentials: false
          token: ${{ secrets.GH_PAT }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Debug repository state
        run: |
          echo "ğŸ” Repository: ${{ github.repository }}"
          echo "ğŸ” Event action: ${{ github.event.action }}"
          echo "ğŸ” PR merged: ${{ github.event.pull_request.merged }}"
          echo "ğŸ” Current tags:"
          git tag --list | head -20 || echo "No tags found"

      - name: Git Semantic Version
        id: tag_version
        uses: PaulHatch/semantic-version@v5.4.0
        with:
          tag_prefix: "v"
          version_format: "${major}.${minor}.${patch}-build${increment}"
          major_pattern: "(MAJOR)"
          minor_pattern: "(MINOR)"
          patch_pattern: "(PATCH)"
          bump_each_commit: true
          version_from_branch: true
          debug: true

      - name: Debug semantic-version outputs
        run: |
          echo "ğŸ¯ version_tag: '${{ steps.tag_version.outputs.version_tag }}'"
          echo "ğŸ¯ version: '${{ steps.tag_version.outputs.version }}'"
          echo "ğŸ¯ major: '${{ steps.tag_version.outputs.major }}'"
          echo "ğŸ¯ minor: '${{ steps.tag_version.outputs.minor }}'"
          echo "ğŸ¯ patch: '${{ steps.tag_version.outputs.patch }}'"
          echo "ğŸ¯ increment: '${{ steps.tag_version.outputs.increment }}'"
          echo "ğŸ¯ new_version: '${{ steps.tag_version.outputs.new_version }}'"
          echo "ğŸ¯ tag_name: '${{ steps.tag_version.outputs.tag_name }}'"

      - name: Generate and push tag with retry logic
        id: generate_tag
        env:
          PAT_TOKEN: ${{ secrets.GH_PAT }}
          REPO_URL: https://x-access-token:${{ secrets.GH_PAT }}@github.com/${{ github.repository }}.git
        run: |
          # Function to check if tag exists locally or remotely
          tag_exists() {
            local tag="$1"
            # Check local first
            if git show-ref --tags --quiet --verify "refs/tags/$tag" 2>/dev/null; then
              return 0
            fi
            # Try to fetch from remote (quietly)
            git fetch origin "refs/tags/$tag:refs/tags/$tag" 2>/dev/null && return 0
            return 1
          }

          # Function to parse version from any format
          parse_version() {
            local version="$1"
            local major minor patch build
            
            # Try different patterns
            # Pattern 1: vX.Y.Z-buildN
            if [[ $version =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)-build([0-9]+)$ ]]; then
              echo "${BASH_REMATCH[1]} ${BASH_REMATCH[2]} ${BASH_REMATCH[3]} ${BASH_REMATCH[4]}"
              return 0
            # Pattern 2: vX.Y.Z (no build suffix)
            elif [[ $version =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
              echo "${BASH_REMATCH[1]} ${BASH_REMATCH[2]} ${BASH_REMATCH[3]} 1"
              return 0
            # Pattern 3: Just the number components
            elif [[ $version =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
              echo "${BASH_REMATCH[1]} ${BASH_REMATCH[2]} ${BASH_REMATCH[3]} 1"
              return 0
            else
              echo "âŒ Could not parse version: $version" >&2
              return 1
            fi
          }

          # Set up authentication for git operations
          echo "ğŸ” Setting up git authentication..."
          git remote set-url origin "$REPO_URL"

          # Get version information - try multiple sources
          if [[ -n "${{ steps.tag_version.outputs.major }}" && \
                -n "${{ steps.tag_version.outputs.minor }}" && \
                -n "${{ steps.tag_version.outputs.patch }}" ]]; then
            # Use direct outputs if available
            MAJOR="${{ steps.tag_version.outputs.major }}"
            MINOR="${{ steps.tag_version.outputs.minor }}"
            PATCH="${{ steps.tag_version.outputs.patch }}"
            INCREMENT="${{ steps.tag_version.outputs.increment }}"
            echo "âœ“ Using direct outputs from semantic-version"
          else
            # Fallback to parsing version_tag
            BASE_VERSION="${{ steps.tag_version.outputs.version_tag }}"
            echo "âš  Falling back to parsing version_tag: $BASE_VERSION"
            if ! parsed=$(parse_version "$BASE_VERSION"); then
              echo "âŒ Failed to parse version. Using defaults."
              MAJOR="0"
              MINOR="0"
              PATCH="0"
              INCREMENT="1"
            else
              read MAJOR MINOR PATCH INCREMENT <<< "$parsed"
            fi
          fi

          # Ensure we have values and increment is at least 1
          MAJOR=${MAJOR:-0}
          MINOR=${MINOR:-0}
          PATCH=${PATCH:-0}
          INCREMENT=${INCREMENT:-1}

          # Ensure increment is at least 1
          if [ "$INCREMENT" -eq "0" ]; then
            echo "âš  Increment is 0, setting to 1"
            INCREMENT=1
          fi

          echo "ğŸ“Š Version components:"
          echo "   Major: $MAJOR"
          echo "   Minor: $MINOR"
          echo "   Patch: $PATCH"
          echo "   Increment: $INCREMENT"

          # Fetch all tags from remote to ensure we have latest state
          echo "ğŸ”„ Fetching all tags from remote..."
          git fetch --tags --force

          # Try up to 10 times to create a unique tag
          MAX_RETRIES=10
          RETRY_COUNT=0
          NEW_TAG=""
          TAG_CREATED=false

          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$TAG_CREATED" = false ]; do
            # Calculate current build number
            CURRENT_BUILD=$((INCREMENT + RETRY_COUNT))
            
            # Generate proposed tag
            PROPOSED_TAG="v${MAJOR}.${MINOR}.${PATCH}-build${CURRENT_BUILD}"
            
            echo "ğŸ”„ Attempt $((RETRY_COUNT + 1))/$MAX_RETRIES: Checking tag '$PROPOSED_TAG'..."
            
            if tag_exists "$PROPOSED_TAG"; then
              echo "   âš  Tag '$PROPOSED_TAG' already exists, trying next build number..."
              RETRY_COUNT=$((RETRY_COUNT + 1))
              continue
            fi
            
            echo "   âœ“ Tag '$PROPOSED_TAG' is available"
            echo "   ğŸ· Creating and pushing tag..."
            
            # Create the tag
            if ! git tag "$PROPOSED_TAG"; then
              echo "   âŒ Failed to create local tag"
              RETRY_COUNT=$((RETRY_COUNT + 1))
              continue
            fi
            
            # Try to push the tag with authentication
            echo "   ğŸ“¤ Pushing tag to remote..."
            if git push origin "$PROPOSED_TAG" 2>&1; then
              NEW_TAG="$PROPOSED_TAG"
              TAG_CREATED=true
              echo "   âœ… Successfully created and pushed tag: $NEW_TAG"
              
              # Verify the tag was created on remote
              echo "   ğŸ” Verifying remote tag..."
              git fetch --tags --force
              if git show-ref --verify "refs/tags/$NEW_TAG" >/dev/null 2>&1; then
                echo "   âœ… Tag verified on remote"
              else
                echo "   âš  Tag created but verification failed - continuing anyway"
              fi
            else
              echo "   âŒ Failed to push tag to remote"
              echo "   Debug info:"
              echo "     REPO_URL: $REPO_URL"
              echo "     Remote: $(git remote -v)"
              # Clean up local tag
              git tag -d "$PROPOSED_TAG" 2>/dev/null || true
              RETRY_COUNT=$((RETRY_COUNT + 1))
            fi
          done

          if [ "$TAG_CREATED" = false ]; then
            echo ""
            echo "âŒ CRITICAL: Failed to create unique tag after $MAX_RETRIES attempts"
            echo "   Last attempted: v${MAJOR}.${MINOR}.${PATCH}-build$((INCREMENT + RETRY_COUNT - 1))"
            echo "   Existing tags in range:"
            git tag --list "v${MAJOR}.${MINOR}.${PATCH}-build*" | sort -V | tail -5 || echo "   No matching tags found"
            echo ""
            echo "Authentication troubleshooting:"
            echo "   1. Check if GH_PAT secret is set correctly"
            echo "   2. Ensure PAT has 'repo' scope permissions"
            echo "   3. Verify repository name: ${{ github.repository }}"
            exit 1
          fi

          # Set outputs
          echo "TAG=$NEW_TAG" >> $GITHUB_ENV
          echo "tag=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "version=${MAJOR}.${MINOR}.${PATCH}" >> $GITHUB_ENV
          echo "build=${CURRENT_BUILD}" >> $GITHUB_ENV

      - name: Verify and display tags
        run: |
          echo "ğŸ“‹ TAG created: ${{ env.TAG }}"
          echo "ğŸ“‹ Version: ${{ env.version }}"
          echo "ğŸ“‹ Build: ${{ env.build }}"

          echo ""
          echo "ğŸ“Š Latest 5 tags:"
          git fetch --tags --force
          git tag --list --sort=-version:refname | head -5

          echo ""
          echo "ğŸ“Š Tags matching current version pattern:"
          git tag --list "v${{ env.version }}-build*" | sort -V || echo "No matching tags"

      - name: Show success message
        if: success()
        run: |
          echo "ğŸ‰ Successfully created tag: ${{ env.TAG }}"
          echo "ğŸ“ˆ Next build number will be: $(( {{ env.build }} + 1 ))"
